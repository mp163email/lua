---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by wangyu.
--- DateTime: 2019-2-18 17:45
---
---
------协程可以将一个函数在运行中中断，然后还能在把他唤醒，继续执行
---*****协程用到最多的是yield和resume之间的取值， yield能把参数返回给resume,  resume也可以把多余的参数，给yield当返回值*****
---将一个数组中元素的所有排列组合打印出来
index = 0
pp = 0
function permgen (a, n)
    n = n or #a
    if n <= 1 then
        pp = pp + 1
        --printResult(a)--啥都不用模式
        coroutine.yield(a)--协程迭代器模式, 到输出的时候不让输出， forin的时候才给输出
    else
        for i = 1, n do
            a[n], a[i] =  a[i], a[n]
            --for j, v in ipairs(a) do
            --    io.write("------->", v,  "(n=", n, " i=", i, ")")
            --end
            --io.write("\n")
            index = index + 1
            permgen(a, n - 1)
            a[n], a[i] =  a[i], a[n]
        end
    end
end

function printResult(a)
    for i = 1, #a do
        io.write(a[i], " ")
    end
    io.write("\n")
end


--定义一个协程函数工厂
function permutations (a)
    local ccc = coroutine.create(function()
            permgen(a)
    end)
    return function()
        local code, res = coroutine.resume(ccc)
        return res
    end
end

for p in permutations{1, 2, 3, 4} do
    printResult(p)
end

--local t1 = {1, 2, 3, 4, 5}
--permgen(t1)
--print(index, pp)

---递归调用次数与最终产出的次数计算公式如下
--[[
n=5
则
递归次数=5 + 5*4 + 5*4*3 + 5*4*3*2
输出次数=5*4*3*2]]
