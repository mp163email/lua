---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by wangyu.
--- DateTime: 2019-2-21 17:42
--- 打印对一个table所做的访问（读和写）
--- 操作test, 通过设置元表的__index和__newindex来操作t,并进行记录

---这种方式只能针对一个，不能通用
---
local t1 = {} --真正用于操作的table
local test ={}--一个傀儡table
local mt = {--一个元表， 用于设置傀儡和元表的关系。可以看到mt里面真正操作的是t1
    __index = function (t, k)
        print("获取："..k)
        return t1[k]
    end,
    __newindex = function (t, k, v)
        print("更新:k="..k..", v="..v)
        t1[k] = v
    end
}
setmetatable(test, mt)
test.a = 10
print(test.a)
print("---------来一种通用的方式--------------")
type = nil--用于控制下面的例子， 一个全局变量
local index ={}
local mt1 = {
    __index = function (t, k)
        print("获取："..k)
        return t[index][k]--将值保存在它自己身上
    end,
    __newindex = function (t, k, v)
        if not type then
            print("更新:k="..k..", v="..v)
            t[index][k] = v
        else
            error("read only, haha")
        end

    end
}
function track (t)--对所有传入的t进行跟踪。函数内对这个t进行了包装，返回了他的代理
    local proxy = {}
    proxy[index] = t
    setmetatable(proxy, mt1)
    return proxy
end
local myt1 = track({a = 1, b = 2})
myt1.c = 3
print(myt1.c)

-------只读的table-------
---通过代理的方式， 在上面将读写都作用于自己身上， 在上面的基础上， 把写操作屏蔽掉就是只读的了。
print("---只读的table---")
type = 1
local xingqi = track({"monday"})
xingqi.x = 10


