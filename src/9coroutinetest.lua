---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by wangyu.
--- DateTime: 2019-2-20 10:11
---

--存放协同程序,进行管理
threads = {}

--创建协同程序的工厂
function create(f)
    local co = coroutine.create(f)
    table.insert(threads, co)
end

--定义2个协同函数
function f1 ()
    while true do
        --为了测试，这里定义一个死循环。
    end
end
function f2()
    for i = 1, 10 do
        coroutine.yield(i)--唤醒10次可以结束
    end
end
function f3()
    for i = 1, 5 do
        coroutine.yield(i)--唤醒5次可以结束
    end
end
function f4()
    for i = 1, 100 do
        coroutine.yield(i)--唤醒100次可以结束
    end
end

--创建这两个协同程序
--create(f1)--测试结果：当一个协同程序运行的时候，其他所有的协程都不能运行
create(f2)
create(f3)
create(f4)
--[[测试代码：当删除一个table的元素，table的下标会重新排列
print(threads[1])
print(threads[2])
print(threads[3])
table.remove(threads, 2)
print("--------")
print(threads[1])
print(threads[2])
print(threads[3])
print("--------")]]

--执行协同函数
function dist ()
    local i = 1
    while true do
        if threads[i] == nil then
            if threads[1] == nil then
                break --如果列表中的第1个元素为空了，说明列表中的全部元素都删除完了
            end
            i = 1--重置控制变量
        end
        local status, value = coroutine.resume(threads[i])--不断的对协程进行唤醒
        if not value then
            table.remove(threads, i)--删除了以后， threads的下标会重新排列，这个时候要重置控制变量，然后重新开始循环
        else
            if threads[i] then
                print(threads[i], value)
            end
        end
        i = i + 1
    end
end
dist()




